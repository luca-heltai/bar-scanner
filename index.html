<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bar Scanner</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 600px;
            margin: auto;
            width: 100%;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
        }

        #reader {
            width: 100%;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            display: none;
        }

        #reader.active {
            display: block;
        }

        button {
            width: 100%;
            padding: 18px;
            font-size: 18px;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 20px;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #switchCameraButton {
            display: none;
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            background: #f9f9f9;
        }

        .status {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }

        .error {
            color: #e74c3c;
        }

        .success {
            color: #27ae60;
        }

        .history-section {
            margin-top: 30px;
            border-top: 2px solid #e0e0e0;
            padding-top: 20px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .history-title {
            color: #333;
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }

        #clearHistoryButton {
            width: auto;
            padding: 10px 20px;
            font-size: 14px;
            margin-bottom: 0;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        #clearHistoryButton:hover:not(:disabled) {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
        }

        #scanHistory {
            width: 100%;
            min-height: 200px;
            max-height: 400px;
            padding: 15px;
            font-size: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            background: #f9f9f9;
            overflow-y: auto;
        }

        .empty-history {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 40px 20px;
        }

        .log-section {
            margin-top: 20px;
            border-top: 2px solid #e0e0e0;
            padding-top: 15px;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .log-title {
            color: #666;
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }

        .log-toggle {
            color: #666;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .log-toggle.expanded {
            /* no visual rotation; we use explicit ‚ñ≤/‚ñº characters so state is deterministic */
            transform: none;
        }

        #logArea {
            width: 100%;
            height: 200px;
            padding: 10px;
            font-size: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            background: #f8f8f8;
            color: #333;
            overflow-y: auto;
            display: none;
        }

        #logArea.expanded {
            display: block;
        }

        .log-entry {
            margin-bottom: 2px;
            word-wrap: break-word;
        }

        .log-entry.error {
            color: #e74c3c;
        }

        .log-entry.warn {
            color: #f39c12;
        }

        .log-entry.info {
            color: #3498db;
        }

        .log-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background: #e74c3c;
            color: white;
            font-size: 12px;
            border-radius: 999px;
            margin-left: 8px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üì± Bar Scanner</h1>
        <div id="reader"></div>
        <button id="scanButton">Scan</button>
        <button id="switchCameraButton">Switch Camera</button>
        <textarea id="result" readonly placeholder="Scanned codes will appear here..."></textarea>
        <div id="status" class="status"></div>

        <div class="history-section">
            <div class="history-header">
                <h2 class="history-title">üìä Scan History</h2>
                <button id="clearHistoryButton">Clear History</button>
            </div>
            <div id="scanHistory" class="empty-history">No scans yet. Start scanning to build your history!</div>
        </div>

        <div class="log-section">
            <div class="log-header" id="logHeader">
                <h3 class="log-title">üîç Debug Logs <span id="logBadge" class="log-badge" style="display:none">0</span>
                </h3>
                <span class="log-toggle" id="logToggle">‚ñº</span>
            </div>
            <textarea id="logArea" readonly placeholder="Debug logs will appear here..."></textarea>
            <div style="margin-top:8px; display:flex; justify-content:flex-end;">
                <button id="clearLogButton" style="width:auto; padding:8px 14px; font-size:13px; margin:0;">Clear
                    Log</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.8/html5-qrcode.min.js"
        onerror="window.html5QrcodeLoadError = true; console.log('Html5Qrcode CDN failed to load')"></script>
    <script>
        (function () {
            // --- Logging utility -------------------------------------------------
            const logArea = document.getElementById('logArea');
            const logToggle = document.getElementById('logToggle');
            const logHeader = document.getElementById('logHeader');
            const clearLogButton = document.getElementById('clearLogButton');

            // unread badge element and initial state
            const logBadge = document.getElementById('logBadge');
            let unreadCount = 0;

            // initialize toggle arrow based on current log visibility
            if (logToggle) {
                const expandedOnLoad = logArea && logArea.classList.contains('expanded');
                logToggle.classList.toggle('expanded', expandedOnLoad);
                logToggle.textContent = expandedOnLoad ? '‚ñ≤' : '‚ñº';
            }

            function updateBadge() {
                if (!logBadge) return;
                if (unreadCount > 0) {
                    logBadge.style.display = '';
                    logBadge.textContent = unreadCount > 99 ? '99+' : String(unreadCount);
                } else {
                    logBadge.style.display = 'none';
                }
            }

            function timeStamp() {
                return new Date().toLocaleString();
            }

            function appendLog(message, level = 'info') {
                try {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry ' + (level || 'info');
                    entry.textContent = `[${timeStamp()}] ${message}`;
                    // Append to textarea-friendly area
                    if (logArea) {
                        // keep textarea content + scroll to top so newest is visible
                        logArea.value = entry.textContent + '\n' + logArea.value;
                        // keep the scroll at top so newest messages are visible
                        logArea.scrollTop = 0;
                        // If the log is collapsed, increment unread count
                        const isExpanded = logArea.classList.contains('expanded');
                        if (!isExpanded) {
                            unreadCount += 1;
                            updateBadge();
                        }
                    }
                    // Also print to console for developer debugging
                    if (level === 'error') console.error(entry.textContent);
                    else if (level === 'warn') console.warn(entry.textContent);
                    else console.log(entry.textContent);
                } catch (e) {
                    console.log(`[${timeStamp()}] Failed to append log: ${e}`);
                }
            }

            // Toggle behavior for the log area
            if (logHeader) {
                logHeader.addEventListener('click', () => {
                    if (!logArea) return;
                    const expanded = logArea.classList.toggle('expanded');
                    logToggle.classList.toggle('expanded', expanded);
                    logToggle.textContent = expanded ? '‚ñ≤' : '‚ñº';
                    // Reset unread count when opening the log
                    if (expanded) {
                        unreadCount = 0;
                        updateBadge();
                    }
                    appendLog(`Toggled log ${expanded ? 'open' : 'closed'}`);
                });
            }

            if (clearLogButton) {
                clearLogButton.addEventListener('click', () => {
                    if (logArea) logArea.value = '';
                    // clearing log also resets unread count
                    unreadCount = 0;
                    updateBadge();
                    appendLog('Log cleared by user', 'info');
                });
            }

            appendLog('Script initialized', 'info');
            // ---------------------------------------------------------------------
            let html5QrcodeInstance = null;
            let preferredCameraId = null;
            let isScanning = false;
            let isPaused = false; // Track if scanning is paused vs stopped
            let barcodeDetector = null;
            let mediaStream = null;
            let animationFrameId = null;
            let activeScanner = null;
            let successMessageTimeoutId = null;
            let barcodeVideoElement = null;
            let html5CameraList = [];
            let cameraIndex = -1;
            let html5HasMultipleCameras = false;
            const fallbackFacingModes = ['environment', 'user'];
            let fallbackFacingIndex = 0;
            let fallbackCameraCount = 0;

            // EAN-first strategy: attempt EAN-13 only initially, then fallback
            const EAN_ONLY_FALLBACK_MS = 5000;
            let eanFallbackTimer = null;
            let eanModeActive = false;

            // Permission caching to avoid repeated permission checks
            let cameraPermissionState = null;
            let lastPermissionCheck = 0;
            const PERMISSION_CACHE_TTL = 30000; // 30 seconds

            function pauseScanning() {
                appendLog('pauseScanning() called');
                if (!isScanning) return;

                isPaused = true;
                scanButton.textContent = 'Scan';
                scanButton.disabled = false;
                switchCameraButton.disabled = true;

                // Stop media tracks immediately to release camera hardware (turn off LED)
                try {
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => {
                            try { track.stop(); } catch (e) { /* ignore */ }
                        });
                        mediaStream = null;
                    }

                    // Remove any video element used by BarcodeDetector
                    if (barcodeVideoElement) {
                        try {
                            if (barcodeVideoElement.srcObject) {
                                barcodeVideoElement.pause();
                                barcodeVideoElement.srcObject = null;
                            }
                            if (barcodeVideoElement.parentElement === readerDiv) {
                                readerDiv.removeChild(barcodeVideoElement);
                            }
                        } catch (e) {
                            // ignore
                        }
                        barcodeVideoElement = null;
                    }

                    // If html5Qrcode instance exists, stop it silently and clear the instance to avoid dangling tracks
                    if (html5QrcodeInstance) {
                        stopHtml5QrcodeSilently();
                        try { html5QrcodeInstance = null; } catch (e) { /* ignore */ }
                    }
                } catch (e) {
                    console.warn('Error while releasing camera on pause:', e);
                }

                // Hide the reader UI
                resetReader();
                // Mark scanning stopped because we've released camera resources
                isScanning = false;
                activeScanner = null;
            }

            async function resumeScanning() {
                appendLog('resumeScanning() called');
                if (!isScanning || !isPaused) return;

                isPaused = false;
                scanButton.textContent = 'Stop Scanning';
                switchCameraButton.disabled = false;

                // Show camera UI
                ensureReaderActive();
                setStatus('Point camera at barcode or QR code');

                // If there's already an active scanner (html5-qrcode or barcode-detector)
                // we shouldn't stop and restart it because that can trigger a camera
                // permission prompt in some browsers. Just return - the scanner should
                // already be running and will resume decoding.
                if (activeScanner) {
                    appendLog('resumeScanning: activeScanner present, not restarting to avoid permission prompt');
                    return;
                }

                // Otherwise, start scanning normally
                try {
                    await startScanning();
                } catch (err) {
                    console.warn('Failed to start scanner on resume:', err);
                    setStatus('Error restarting scanner', 'error');
                }
            }

            async function checkCameraPermission() {
                appendLog('checkCameraPermission() called');
                const now = Date.now();

                // Use cached permission state if it's recent
                if (cameraPermissionState && (now - lastPermissionCheck) < PERMISSION_CACHE_TTL) {
                    return cameraPermissionState;
                }

                // Only check permissions if the API is available
                if (!navigator.permissions || !navigator.permissions.query) {
                    // If permission API is not available, assume we need to try camera access
                    cameraPermissionState = 'prompt';
                    lastPermissionCheck = now;
                    return cameraPermissionState;
                }

                try {
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    cameraPermissionState = permissionStatus.state;
                    lastPermissionCheck = now;

                    // Listen for permission changes to update our cache
                    permissionStatus.onchange = () => {
                        cameraPermissionState = permissionStatus.state;
                        lastPermissionCheck = Date.now();
                    };

                    return cameraPermissionState;
                } catch (err) {
                    console.log('Permission query failed, proceeding with camera access');
                    cameraPermissionState = 'prompt';
                    lastPermissionCheck = now;
                    return cameraPermissionState;
                }
            }

            const recentResults = new Map();
            const RESULT_DEBOUNCE_MS = 1500;
            const RESULT_HISTORY_TTL_MS = 15000;

            const scanButton = document.getElementById('scanButton');
            const resultTextarea = document.getElementById('result');
            const readerDiv = document.getElementById('reader');
            const statusDiv = document.getElementById('status');
            const switchCameraButton = document.getElementById('switchCameraButton');
            const clearHistoryButton = document.getElementById('clearHistoryButton');
            const scanHistoryDiv = document.getElementById('scanHistory');
            switchCameraButton.disabled = true;

            // Scan history storage
            let scanHistory = [];
            const MAX_HISTORY_ITEMS = 50;

            function addToHistory(decodedText, codeType, timestamp) {
                appendLog(`addToHistory() called - ${decodedText}`);
                const historyItem = {
                    text: decodedText,
                    type: codeType,
                    timestamp: timestamp,
                    id: Date.now() + Math.random() // Simple unique ID
                };

                scanHistory.unshift(historyItem); // Add to beginning

                // Keep only the most recent items
                if (scanHistory.length > MAX_HISTORY_ITEMS) {
                    scanHistory = scanHistory.slice(0, MAX_HISTORY_ITEMS);
                }

                updateHistoryDisplay();
                saveHistoryToLocalStorage();
            }

            function updateHistoryDisplay() {
                appendLog('updateHistoryDisplay() called');
                if (scanHistory.length === 0) {
                    scanHistoryDiv.innerHTML = '<div class="empty-history">No scans yet. Start scanning to build your history!</div>';
                    scanHistoryDiv.className = 'empty-history';
                    return;
                }

                scanHistoryDiv.className = '';
                let historyHTML = '';

                scanHistory.forEach((item, index) => {
                    const shortText = item.text.length > 60 ? item.text.substring(0, 60) + '...' : item.text;
                    historyHTML += `
                        <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 8px; border-left: 4px solid #667eea;">
                            <div style="font-weight: bold; color: #333; margin-bottom: 5px;">
                                ${item.type} - ${item.timestamp}
                            </div>
                            <div style="font-family: 'Courier New', monospace; word-break: break-all; color: #555;">
                                ${shortText}
                            </div>
                        </div>
                    `;
                });

                scanHistoryDiv.innerHTML = historyHTML;
            }

            function clearHistory() {
                appendLog('clearHistory() called');
                scanHistory = [];
                updateHistoryDisplay();
                saveHistoryToLocalStorage();
                setStatus('History cleared', 'success');
                setTimeout(() => {
                    if (statusDiv.textContent === 'History cleared') {
                        setStatus('');
                    }
                }, 1500);
            }

            function saveHistoryToLocalStorage() {
                appendLog('saveHistoryToLocalStorage() called');
                try {
                    localStorage.setItem('barScannerHistory', JSON.stringify(scanHistory));
                } catch (err) {
                    console.warn('Failed to save history to localStorage:', err);
                }
            }

            function loadHistoryFromLocalStorage() {
                appendLog('loadHistoryFromLocalStorage() called');
                try {
                    const saved = localStorage.getItem('barScannerHistory');
                    if (saved) {
                        scanHistory = JSON.parse(saved);
                        updateHistoryDisplay();
                    }
                } catch (err) {
                    console.warn('Failed to load history from localStorage:', err);
                    scanHistory = [];
                }
            }

            function setStatus(message, type = 'info') {
                appendLog(`setStatus() called - ${message}`);
                statusDiv.textContent = message;

                if (!message) {
                    statusDiv.className = 'status';
                    return;
                }

                if (type === 'success') {
                    statusDiv.className = 'status success';
                } else if (type === 'error') {
                    statusDiv.className = 'status error';
                } else {
                    statusDiv.className = 'status';
                }
            }

            function updateSwitchCameraButton() {
                appendLog('updateSwitchCameraButton() called');
                const hasMultiple = (canUseHtml5Qrcode() && html5HasMultipleCameras) || fallbackCameraCount > 1;
                if (hasMultiple) {
                    switchCameraButton.style.display = '';
                    switchCameraButton.disabled = !isScanning;
                } else {
                    switchCameraButton.style.display = 'none';
                }
            }

            function describeCameraFromState(scanner = activeScanner) {
                appendLog('describeCameraFromState() called');
                if (scanner === 'html5-qrcode' && html5CameraList.length > 0 && cameraIndex >= 0 && cameraIndex < html5CameraList.length) {
                    const label = html5CameraList[cameraIndex].label;
                    return label || `Camera ${cameraIndex + 1}`;
                }

                if (scanner === 'barcode-detector') {
                    const facing = fallbackFacingModes[fallbackFacingIndex] || 'environment';
                    return facing === 'user' ? 'Front camera' : 'Back camera';
                }

                if (html5CameraList.length > 0 && cameraIndex >= 0 && cameraIndex < html5CameraList.length) {
                    const label = html5CameraList[cameraIndex].label;
                    return label || `Camera ${cameraIndex + 1}`;
                }

                const fallbackFacing = fallbackFacingModes[fallbackFacingIndex] || 'environment';
                return fallbackFacing === 'user' ? 'Front camera' : 'Back camera';
            }

            function recordResult(decodedText) {
                appendLog(`recordResult() called - ${decodedText}`);
                if (!decodedText) {
                    return false;
                }

                const normalized = decodedText.trim();
                if (!normalized) {
                    return false;
                }

                const now = Date.now();
                const lastSeen = recentResults.get(normalized);
                if (lastSeen && now - lastSeen < RESULT_DEBOUNCE_MS) {
                    return false;
                }

                recentResults.set(normalized, now);

                for (const [text, timestamp] of recentResults) {
                    if (now - timestamp > RESULT_HISTORY_TTL_MS) {
                        recentResults.delete(text);
                    }
                }

                return true;
            }

            function detectCodeType(decodedText) {
                appendLog(`detectCodeType() called - ${decodedText}`);
                // Simple heuristics to detect barcode/QR code types
                if (!decodedText) return 'Unknown';

                const text = decodedText.trim();

                // QR Code patterns
                if (text.startsWith('http://') || text.startsWith('https://')) return 'QR Code (URL)';
                if (text.startsWith('mailto:')) return 'QR Code (Email)';
                if (text.startsWith('tel:')) return 'QR Code (Phone)';
                if (text.startsWith('wifi:')) return 'QR Code (WiFi)';
                if (text.includes('\n') || text.length > 50) return 'QR Code (Text)';

                // Barcode patterns based on length and format
                if (/^\d{13}$/.test(text)) return 'EAN-13 Barcode';
                if (/^\d{12}$/.test(text)) return 'UPC-A Barcode';
                if (/^\d{8}$/.test(text)) return 'EAN-8 Barcode';
                if (/^\d{6}$/.test(text)) return 'UPC-E Barcode';
                if (/^[0-9A-Z\-\.\$\/\+\%\s]+$/.test(text) && text.length >= 3) return 'Code 39 Barcode';
                if (/^[\x00-\x7F]+$/.test(text) && text.length >= 4) return 'Code 128 Barcode';

                // Default based on content
                if (/^\d+$/.test(text)) return 'Numeric Barcode';
                if (text.length <= 20) return 'Barcode';

                return 'QR Code';
            }

            function displayCodeInfo(decodedText, codeType) {
                appendLog(`displayCodeInfo() called - ${decodedText}`);
                const timestamp = new Date().toLocaleString();
                const codeInfo = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üìÖ Scan Time: ${timestamp}
üè∑Ô∏è  Code Type: ${codeType}
üìä Raw Value: ${decodedText}
üìè Length: ${decodedText.length} characters
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

`;
                resultTextarea.value = codeInfo + resultTextarea.value;
                resultTextarea.scrollTop = 0;

                // Add to history
                addToHistory(decodedText, codeType, timestamp);
            }

            function handleSuccessfulScanUI(decodedText, codeType) {
                appendLog(`handleSuccessfulScanUI() called - ${decodedText}`);
                if (successMessageTimeoutId) {
                    clearTimeout(successMessageTimeoutId);
                }

                setStatus(`‚úì ${codeType} captured! Click scan to continue.`, 'success');
                displayCodeInfo(decodedText, codeType);

                // Pause scanning instead of stopping completely to avoid permission re-request
                pauseScanning();
            }

            function addResult(decodedText) {
                appendLog(`addResult() called - ${decodedText}`);
                const codeType = detectCodeType(decodedText);
                handleSuccessfulScanUI(decodedText, codeType);
            }

            function onScanSuccess(decodedText) {
                appendLog(`onScanSuccess() called - ${decodedText}`);
                // Cancel EAN-only fallback if running
                try { if (eanFallbackTimer) { clearTimeout(eanFallbackTimer); eanFallbackTimer = null; } } catch (e) { }
                eanModeActive = false;

                if (recordResult(decodedText)) {
                    addResult(decodedText);
                }
            }

            // Throttled, informative scan error handler
            let _lastScanErrorMsg = null;
            let _lastScanErrorTime = 0;
            let _scanErrorBurst = 0;
            function onScanError(err) {
                // err may be a string or Error-like
                const now = Date.now();
                const msg = err && err.message ? err.message : String(err || 'decode error');

                // If same message repeating quickly, increment burst counter and only log occasionally
                if (msg === _lastScanErrorMsg && (now - _lastScanErrorTime) < 500) {
                    _scanErrorBurst += 1;
                    // log a summary every 10 repeats to avoid flooding the UI
                    if (_scanErrorBurst % 10 === 0) {
                        appendLog(`onScanError: ${msg} (repeated ${_scanErrorBurst} times)`, 'warn');
                    }
                } else {
                    _lastScanErrorMsg = msg;
                    _lastScanErrorTime = now;
                    _scanErrorBurst = 0;
                    appendLog(`onScanError: ${msg}`, 'warn');
                }

                // If we're getting continuous decode errors for a while, hint to the user
                if (_scanErrorBurst > 50) {
                    setStatus('Decoding consistently failing ‚Äî try better lighting, move camera closer, or rotate the code', 'error');
                }
            }

            function canUseHtml5Qrcode() {
                appendLog('canUseHtml5Qrcode() called');
                // Check if library loaded and is functional
                if (window.html5QrcodeLoadError) {
                    appendLog('canUseHtml5Qrcode: CDN load reported error (window.html5QrcodeLoadError=true)', 'warn');
                    console.log('Html5Qrcode library failed to load from CDN');
                    return false;
                }

                if (typeof Html5Qrcode === 'undefined') {
                    appendLog('canUseHtml5Qrcode: Html5Qrcode is undefined (library not loaded)', 'warn');
                    console.log('Html5Qrcode not available');
                    return false;
                }

                // Additional check to ensure the library is functional
                try {
                    // Test if we can enumerate cameras
                    if (typeof Html5Qrcode.getCameras !== 'function') {
                        appendLog('canUseHtml5Qrcode: Html5Qrcode.getCameras not available', 'warn');
                        console.log('Html5Qrcode.getCameras not available');
                        return false;
                    }
                    appendLog('canUseHtml5Qrcode: Html5Qrcode appears available', 'info');
                    return true;
                } catch (err) {
                    appendLog(`canUseHtml5Qrcode: functionality test threw: ${err && err.message ? err.message : err}`, 'warn');
                    console.log('Html5Qrcode functionality test failed:', err);
                    return false;
                }
            }

            function canUseBarcodeDetector() {
                appendLog('canUseBarcodeDetector() called');
                if (!('BarcodeDetector' in window)) {
                    appendLog('canUseBarcodeDetector: BarcodeDetector API not found in window', 'warn');
                    console.log('BarcodeDetector API not available');
                    // Not returning yet ‚Äî some browsers might not have BarcodeDetector but can use html5-qrcode.
                    return false;
                }

                // Additional check for mobile compatibility
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    appendLog('canUseBarcodeDetector: navigator.mediaDevices.getUserMedia not available', 'warn');
                    console.log('getUserMedia not available');
                    return false;
                }

                appendLog('canUseBarcodeDetector: BarcodeDetector and getUserMedia available', 'info');
                return true;
            }

            async function refreshHtml5CameraList() {
                appendLog('refreshHtml5CameraList() called');
                if (!canUseHtml5Qrcode() || typeof Html5Qrcode.getCameras !== 'function') {
                    html5CameraList = [];
                    html5HasMultipleCameras = false;
                    updateSwitchCameraButton();
                    return;
                }

                try {
                    const cameras = await Html5Qrcode.getCameras();
                    if (!Array.isArray(cameras) || cameras.length === 0) {
                        html5CameraList = [];
                        html5HasMultipleCameras = false;
                        updateSwitchCameraButton();
                        return;
                    }

                    html5CameraList = cameras;
                    html5HasMultipleCameras = cameras.length > 1;

                    let resolvedIndex = -1;

                    if (preferredCameraId) {
                        resolvedIndex = cameras.findIndex(camera => camera.id === preferredCameraId);
                    }

                    if (resolvedIndex === -1 && cameraIndex >= 0 && cameraIndex < cameras.length) {
                        resolvedIndex = cameraIndex;
                        preferredCameraId = cameras[resolvedIndex].id;
                    }

                    if (resolvedIndex === -1) {
                        const rearIndex = cameras.findIndex(camera =>
                            /back|rear|environment/i.test(camera.label)
                        );
                        resolvedIndex = rearIndex >= 0 ? rearIndex : 0;
                        preferredCameraId = cameras[resolvedIndex].id;
                    }

                    cameraIndex = resolvedIndex;
                    updateSwitchCameraButton();
                } catch (err) {
                    console.warn('Failed to enumerate camera devices:', err);
                }
            }

            function syncActiveHtml5CameraFromTrack() {
                appendLog('syncActiveHtml5CameraFromTrack() called');
                if (!html5QrcodeInstance || typeof html5QrcodeInstance.getRunningTrackSettings !== 'function') {
                    return;
                }

                const settings = html5QrcodeInstance.getRunningTrackSettings();
                if (!settings || !settings.deviceId) {
                    return;
                }

                preferredCameraId = settings.deviceId;

                if (html5CameraList.length > 0) {
                    const runningIndex = html5CameraList.findIndex(camera => camera.id === preferredCameraId);
                    if (runningIndex >= 0) {
                        cameraIndex = runningIndex;
                    }
                }
            }

            function ensureReaderActive() {
                appendLog('ensureReaderActive() called');
                readerDiv.classList.add('active');
            }

            function resetReader() {
                appendLog('resetReader() called');
                readerDiv.classList.remove('active');
            }

            function teardownSuccessTimer() {
                appendLog('teardownSuccessTimer() called');
                if (successMessageTimeoutId) {
                    clearTimeout(successMessageTimeoutId);
                    successMessageTimeoutId = null;
                }
            }

            async function startHtml5Qrcode(cameraIdOverride, formatsToSupport) {
                appendLog(`startHtml5Qrcode() called - override: ${cameraIdOverride} formats:${formatsToSupport ? formatsToSupport.join(',') : 'default'}`);
                ensureReaderActive();

                // Clear any leftover elements inside reader to avoid collision between
                // BarcodeDetector video element and Html5Qrcode's own canvas/video
                try {
                    readerDiv.innerHTML = '';
                } catch (e) {
                    console.warn('Failed to clear reader div before html5-qrcode start', e);
                }

                if (!html5QrcodeInstance) {
                    html5QrcodeInstance = new Html5Qrcode('reader');
                }

                // Simplified camera configuration - let browser/user choose initially
                let cameraConfig;
                if (cameraIdOverride) {
                    cameraConfig = { deviceId: { exact: cameraIdOverride } };
                    preferredCameraId = cameraIdOverride;
                } else {
                    // Use facingMode string for html5-qrcode compatibility on some mobiles
                    cameraConfig = { facingMode: 'environment' };
                }

                const config = {
                    // Slightly higher FPS can improve detection responsiveness on modern mobiles
                    fps: 15,
                    // Dynamic qrbox sizing with clamps ‚Äî on small viewfinders a too-large qrbox
                    // can reduce detection performance. Clamp to a sensible pixel size.
                    qrbox: function (viewfinderWidth, viewfinderHeight) {
                        const minEdgeSize = Math.min(viewfinderWidth, viewfinderHeight);
                        // target between 40% and 70% of min edge
                        const pct = Math.max(0.4, Math.min(0.7, 0.6));
                        let qrboxSize = Math.floor(minEdgeSize * pct);
                        // clamp to reasonable pixel sizes to avoid overly large qrbox on tablets
                        qrboxSize = Math.max(200, Math.min(400, qrboxSize));
                        return {
                            width: qrboxSize,
                            height: qrboxSize
                        };
                    }
                };

                // Simplified format support for better compatibility
                if (typeof Html5QrcodeSupportedFormats !== 'undefined') {
                    const formats = Html5QrcodeSupportedFormats;
                    if (Array.isArray(formatsToSupport) && formatsToSupport.length > 0) {
                        // Map string names to constants
                        config.formatsToSupport = formatsToSupport.map(name => formats[name]).filter(Boolean);
                    } else {
                        // Default set (include EAN_13 near the front)
                        config.formatsToSupport = [
                            formats.QR_CODE,
                            formats.EAN_13,
                            formats.EAN_8,
                            formats.CODE_128,
                            formats.CODE_39,
                            formats.UPC_A,
                            formats.UPC_E
                        ];
                    }
                }

                try {
                    await html5QrcodeInstance.start(cameraConfig, config, onScanSuccess, onScanError);
                    appendLog('startHtml5Qrcode: html5QrcodeInstance started successfully');

                    activeScanner = 'html5-qrcode';
                    isScanning = true;
                    scanButton.textContent = 'Stop Scanning';
                } catch (err) {
                    appendLog(`startHtml5Qrcode: failed to start - ${err && err.message ? err.message : err}`, 'error');
                    throw err;
                }

                // Get camera info from the running instance without triggering new permission requests
                try {
                    const settings = html5QrcodeInstance.getRunningTrackSettings();
                    if (settings && settings.deviceId) {
                        preferredCameraId = settings.deviceId;
                    }
                } catch (err) {
                    console.warn('Failed to get camera info:', err);
                }

                // Assume multiple cameras exist for switch functionality without enumerating
                html5HasMultipleCameras = true;

                setStatus('Point camera at barcode or QR code');
                updateSwitchCameraButton();
            } async function startBarcodeDetector() {
                appendLog('startBarcodeDetector() called');
                ensureReaderActive();

                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Camera access is not supported in this browser.');
                }

                const video = document.createElement('video');
                video.style.width = '100%';
                video.style.borderRadius = '10px';
                video.autoplay = true;
                video.playsInline = true;
                readerDiv.appendChild(video);

                try {
                    // Simplified camera constraints for better mobile compatibility
                    const constraints = {
                        video: {
                            facingMode: { ideal: 'environment' },
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 }
                        }
                    };

                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (err) {
                    readerDiv.removeChild(video);
                    // Provide more specific error messages for permission issues
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        throw new Error('Camera permission denied. Please allow camera access and try again.');
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        throw new Error('No camera found. Please connect a camera and try again.');
                    } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                        throw new Error('Camera is already in use by another application.');
                    }
                    throw err;
                }

                video.srcObject = mediaStream;
                barcodeVideoElement = video;

                // Wait for video to be ready
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => resolve();
                    video.onerror = () => reject(new Error('Failed to load video stream'));
                    setTimeout(() => reject(new Error('Video loading timeout')), 10000);
                });

                const playPromise = video.play();
                if (playPromise && typeof playPromise.catch === 'function') {
                    playPromise.catch(() => {
                        // Autoplay can be blocked; the next user interaction will resume playback.
                    });
                }

                // Simplified BarcodeDetector initialization
                try {
                    barcodeDetector = new BarcodeDetector();
                } catch (err) {
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => track.stop());
                        mediaStream = null;
                    }
                    if (video.srcObject) {
                        video.pause();
                        video.srcObject = null;
                    }
                    if (video.parentElement === readerDiv) {
                        readerDiv.removeChild(video);
                    }
                    barcodeVideoElement = null;
                    throw err;
                }

                activeScanner = 'barcode-detector';
                isScanning = true;
                scanButton.textContent = 'Stop Scanning';
                setStatus('Point camera at barcode or QR code (Back camera)');

                // Simple camera count detection - only if we already have permission
                try {
                    if (cameraPermissionState === 'granted') {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoInputs = devices.filter(device => device.kind === 'videoinput');
                        fallbackCameraCount = videoInputs.length;
                    } else {
                        fallbackCameraCount = 2; // Assume at least 2 cameras for switch button
                    }
                } catch (err) {
                    fallbackCameraCount = 1;
                }
                updateSwitchCameraButton();

                const detect = async () => {
                    // appendLog('barcode-detector detection loop tick');
                    if (!isScanning || activeScanner !== 'barcode-detector') {
                        return;
                    }

                    try {
                        const barcodes = await barcodeDetector.detect(video);
                        if (barcodes.length > 0) {
                            const value = barcodes[0].rawValue;
                            if (recordResult(value)) {
                                addResult(value);
                                return; // Stop detection loop after successful scan
                            }
                        }
                    } catch (err) {
                        // Detection errors happen while acquiring frames; ignore them.
                    }

                    animationFrameId = requestAnimationFrame(detect);
                };

                detect();
            }

            async function startScanning() {
                appendLog('startScanning() called');
                if (isScanning) {
                    return;
                }

                // Clear the result textarea when starting a new scan
                resultTextarea.value = '';

                scanButton.disabled = true;
                switchCameraButton.disabled = true;
                teardownSuccessTimer();
                setStatus('Starting camera...');

                try {
                    // Check camera permission state efficiently
                    const permissionState = await checkCameraPermission();

                    if (permissionState === 'denied') {
                        throw new Error('Camera permission denied. Please enable camera access in your browser settings.');
                    }

                    // If permission is 'granted' or 'prompt', proceed with camera access
                    // The actual permission dialog (if needed) will be triggered by the camera access itself

                    if (canUseHtml5Qrcode()) {
                        try {
                            // Start with EAN-13 focused mode first
                            eanModeActive = true;
                            await startHtml5Qrcode(null, ['EAN_13']);

                            // Setup fallback: if no successful scan in EAN_ONLY_FALLBACK_MS, restart with full formats
                            clearTimeout(eanFallbackTimer);
                            eanFallbackTimer = setTimeout(async () => {
                                try {
                                    appendLog('EAN-only timeout reached; restarting with broader formats');
                                    await stopHtml5QrcodeSilently();
                                    eanModeActive = false;
                                    await startHtml5Qrcode();
                                } catch (e) {
                                    console.warn('Failed to fallback to broader formats:', e);
                                }
                            }, EAN_ONLY_FALLBACK_MS);

                            return;
                        } catch (err) {
                            console.warn('Html5Qrcode failed to start, attempting fallback:', err);
                            await stopHtml5QrcodeSilently();
                            eanModeActive = false;
                        }
                    } else {
                        console.log('Html5Qrcode not available, checking fallback options');
                    }

                    if (canUseBarcodeDetector()) {
                        try {
                            await startBarcodeDetector();
                            return;
                        } catch (err) {
                            console.warn('BarcodeDetector failed to start:', err);
                        }
                    } else {
                        console.log('BarcodeDetector not available');
                    }

                    // If we get here, provide helpful error message
                    const isHttps = location.protocol === 'https:';
                    const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';

                    if (!isHttps && !isLocalhost) {
                        throw new Error('Camera access requires HTTPS. Please access this page over HTTPS.');
                    }

                    throw new Error('No barcode scanning capability available. This browser may not support the required camera APIs.');
                } catch (err) {
                    resetReader();
                    const message = err.message || err;
                    if (message.includes('permission') || message.includes('Permission') || message.includes('denied')) {
                        setStatus(`Camera access denied. Please allow camera permissions and try again.`, 'error');
                    } else {
                        setStatus(`Error: ${message}`, 'error');
                    }
                } finally {
                    scanButton.disabled = false;
                    updateSwitchCameraButton();
                }
            }

            async function stopHtml5Qrcode() {
                appendLog('stopHtml5Qrcode() called');
                if (!html5QrcodeInstance) {
                    return;
                }

                let capturedError = null;

                try {
                    await html5QrcodeInstance.stop();
                } catch (err) {
                    const message = err && err.message ? err.message : String(err);
                    if (!/not started|not running/i.test(message)) {
                        capturedError = err;
                    }
                }

                try {
                    await html5QrcodeInstance.clear();
                } catch (err) {
                    if (!capturedError) {
                        capturedError = err;
                    }
                }

                if (capturedError) {
                    throw capturedError;
                }
                // Ensure we clear the instance reference to avoid dangling state
                try { html5QrcodeInstance = null; } catch (e) { /* ignore */ }
            }

            async function stopHtml5QrcodeSilently() {
                appendLog('stopHtml5QrcodeSilently() called');
                try {
                    await stopHtml5Qrcode();
                } catch (err) {
                    console.warn('Failed to fully stop Html5Qrcode:', err);
                }
            }

            function stopBarcodeDetector() {
                appendLog('stopBarcodeDetector() called');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }

                const video = barcodeVideoElement;
                barcodeVideoElement = null;
                if (video) {
                    if (video.srcObject) {
                        video.pause();
                        video.srcObject = null;
                    }
                    if (video.parentElement === readerDiv) {
                        readerDiv.removeChild(video);
                    }
                }

                barcodeDetector = null;
            }

            async function switchHtml5QrcodeCamera() {
                appendLog('switchHtml5QrcodeCamera() called');
                if (!isScanning || activeScanner !== 'html5-qrcode') {
                    return;
                }

                // Simplified camera switching - cycle through available cameras
                if (html5CameraList.length <= 1) {
                    return; // No other cameras to switch to
                }

                const currentIndex = cameraIndex >= 0 ? cameraIndex : 0;
                const nextIndex = (currentIndex + 1) % html5CameraList.length;
                const nextCamera = html5CameraList[nextIndex];

                scanButton.disabled = true;
                switchCameraButton.disabled = true;
                setStatus('Switching camera...');

                try {
                    await stopHtml5Qrcode();
                    isScanning = false;
                    activeScanner = null;

                    // Start with the next camera
                    cameraIndex = nextIndex;
                    preferredCameraId = nextCamera.id;
                    await startHtml5Qrcode(nextCamera.id);

                    const cameraLabel = nextCamera.label || `Camera ${nextIndex + 1}`;
                    setStatus(`Switched to ${cameraLabel}`, 'success');
                    setTimeout(() => {
                        if (isScanning && statusDiv.textContent.startsWith('Switched to')) {
                            const label = describeCameraFromState();
                            setStatus(label ? `Point camera at barcode or QR code (${label})` : 'Point camera at barcode or QR code');
                        }
                    }, 2000);

                } catch (err) {
                    console.error('Camera switch failed:', err);
                    setStatus('Camera switch failed. Please try again.', 'error');

                    // Try to restart with original camera
                    try {
                        cameraIndex = currentIndex;
                        preferredCameraId = html5CameraList[currentIndex].id;
                        await startHtml5Qrcode(preferredCameraId);
                    } catch (restoreErr) {
                        console.error('Failed to restore camera:', restoreErr);
                        setStatus('Camera error. Please restart scanning.', 'error');
                    }
                } finally {
                    scanButton.disabled = false;
                    updateSwitchCameraButton();
                }
            }

            async function switchBarcodeDetectorCamera() {
                appendLog('switchBarcodeDetectorCamera() called');
                if (!isScanning || activeScanner !== 'barcode-detector') {
                    return;
                }

                if (fallbackCameraCount <= 1) {
                    return; // No other cameras available
                }

                // Simple toggle between front and back camera
                const currentFacing = fallbackFacingModes[fallbackFacingIndex] || 'environment';
                const nextFacing = currentFacing === 'environment' ? 'user' : 'environment';

                scanButton.disabled = true;
                switchCameraButton.disabled = true;
                setStatus(`Switching to ${nextFacing === 'user' ? 'front' : 'back'} camera...`);

                stopBarcodeDetector();
                isScanning = false;
                activeScanner = null;

                try {
                    fallbackFacingIndex = fallbackFacingModes.indexOf(nextFacing);
                    await startBarcodeDetector();
                } catch (err) {
                    console.error('Camera switch failed:', err);
                    setStatus('Camera switch failed. Please try again.', 'error');

                    // Try to restore previous camera
                    try {
                        fallbackFacingIndex = fallbackFacingModes.indexOf(currentFacing);
                        await startBarcodeDetector();
                    } catch (restoreErr) {
                        console.error('Failed to restore camera:', restoreErr);
                        setStatus('Camera error. Please restart scanning.', 'error');
                    }
                } finally {
                    scanButton.disabled = false;
                    updateSwitchCameraButton();
                }
            }

            async function stopScanning() {
                appendLog('stopScanning() called');
                if (!isScanning) {
                    return;
                }

                scanButton.disabled = true;
                teardownSuccessTimer();

                try {
                    if (activeScanner === 'html5-qrcode') {
                        await stopHtml5Qrcode();
                    } else if (activeScanner === 'barcode-detector') {
                        stopBarcodeDetector();
                    }
                } catch (err) {
                    console.error('Error stopping scanner:', err);
                    setStatus(`Error stopping: ${err.message || err}`, 'error');
                } finally {
                    isScanning = false;
                    activeScanner = null;
                    // clear any EAN fallback timer
                    try { if (eanFallbackTimer) { clearTimeout(eanFallbackTimer); eanFallbackTimer = null; } } catch (e) { }
                    eanModeActive = false;
                    scanButton.textContent = 'Scan';
                    scanButton.disabled = false;
                    switchCameraButton.disabled = true;
                    resetReader();
                    if (statusDiv.textContent.startsWith('Point camera at barcode or QR code')) {
                        setStatus('');
                    }
                    updateSwitchCameraButton();
                }
            }

            scanButton.addEventListener('click', async () => {
                appendLog('scanButton click handler invoked');
                if (scanButton.disabled) {
                    return;
                }

                if (isScanning && !isPaused) {
                    await stopScanning();
                } else if (isScanning && isPaused) {
                    await resumeScanning();
                } else {
                    await startScanning();
                }
            });

            switchCameraButton.addEventListener('click', async () => {
                appendLog('switchCameraButton click handler invoked');
                if (switchCameraButton.disabled || !isScanning) {
                    return;
                }

                try {
                    if (activeScanner === 'html5-qrcode') {
                        await switchHtml5QrcodeCamera();
                    } else if (activeScanner === 'barcode-detector') {
                        await switchBarcodeDetectorCamera();
                    }
                } catch (err) {
                    console.error('Unexpected camera switch error:', err);
                    setStatus(`Camera switch failed: ${err.message || err}`, 'error');
                }
            });

            clearHistoryButton.addEventListener('click', () => {
                appendLog('clearHistoryButton click handler invoked');
                clearHistory();
            });

            document.addEventListener('visibilitychange', () => {
                appendLog('visibilitychange event');
                // Only stop scanner if page is hidden and we're actually scanning
                // This prevents interference with permission dialogs
                if (document.hidden && isScanning) {
                    // Add a small delay to avoid stopping during permission dialogs
                    setTimeout(() => {
                        if (document.hidden && isScanning) {
                            stopScanning().catch(err => {
                                console.warn('Failed to stop scanner on visibility change:', err);
                            });
                        }
                    }, 1000);
                }
            });

            // Initialize history on page load
            loadHistoryFromLocalStorage();
        })();
    </script>
</body>

</html>